{"ast":null,"code":"import \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { Midi } from \"@tonejs/midi\";\nimport Timer from \"../../utils/SetTimeoutTimer\";\nimport { canvasState, keyboardState, menuState } from \"@/store/consts/states.js\";\nimport { SET_CURRENT_SONG, SET_CURRENT_SONG_DURATION, SET_IS_LOADING, ADD_NEW_RECORDED_SONG, ADD_TIMER, CLEAR_TIMERS, SET_KEY_PRESSED, CLEAR_PRESSED_KEYS } from \"@/store/consts/mutation_types.js\";\nimport { changeSong, clearTimes, pauseTimers, resumeTimers, prepareNotes, prepareSong, stopPlaying, startDraw, stopDraw\n// uploadMIDI,\n// deleteMIDI\n} from \"@/store/consts/actions.js\";\nconst SONGS_URL = \"./songs/\";\nexport default {\n  namespaced: true,\n  state: {\n    songs: [\n    // {name: \"UPLOAD A NEW MIDI FILE\", fromPlaylist: true},\n    {\n      name: \"J. Pachelbel - Canon in D\",\n      fromPlaylist: true\n    }, {\n      name: \"Rick Astley - Never Gonna Give You Up\",\n      fromPlaylist: true\n    }],\n    currentSong: \"\",\n    timers: [],\n    currentSongDuration: 0,\n    isLoading: false\n  },\n  mutations: {\n    [SET_CURRENT_SONG](state, val) {\n      state.currentSong = val;\n    },\n    [SET_CURRENT_SONG_DURATION](state, val) {\n      state.currentSongDuration = val;\n    },\n    [SET_IS_LOADING](state, val) {\n      state.isLoading = val;\n    },\n    [ADD_NEW_RECORDED_SONG](state, val) {\n      state.songs.unshift(val);\n    },\n    [ADD_TIMER](state, timer) {\n      state.timers.push(timer);\n    },\n    [CLEAR_TIMERS](state) {\n      state.timers.length = 0;\n    }\n    // [UPLOAD_SONG](state, val) {\n    //     state.songs.unshift(val);\n    // },\n    // [DELETE_SONG](state, val) {\n    //     idx = state.songs.indexOf(val);\n    //     state.songs.splice(idx, 1);\n    // }\n  },\n\n  actions: {\n    [changeSong]({\n      commit,\n      dispatch\n    }, currentSong) {\n      commit(SET_CURRENT_SONG, currentSong);\n      if (currentSong != \"\") {\n        dispatch(prepareSong);\n      }\n      // let flag = True\n      // while (flag == True) {\n      //     commit(SET_CURRENT_SONG, currentSong);\n      //     if(currentSong != \"\"){\n      //         dispatch(prepareSong);\n      //         flag = False\n      //     }\n      //     // else if (currentSong == \"UPLOAD A NEW MIDI FILE\") {\n\n      //     // }\n      // }\n    },\n\n    [clearTimes]({\n      state,\n      commit\n    }) {\n      state.timers.forEach(timer => timer.pause());\n      commit(CLEAR_TIMERS);\n    },\n    [pauseTimers]({\n      state\n    }) {\n      state.timers.forEach(timer => timer.pause());\n    },\n    [resumeTimers]({\n      state\n    }) {\n      state.timers.forEach(timer => timer.resume());\n    },\n    [prepareNotes]({\n      state,\n      rootState,\n      commit,\n      dispatch\n    }, {\n      notes,\n      lastSong\n    }) {\n      notes.forEach((note, i) => {\n        if (lastSong && i === notes.length - 1) {\n          commit(SET_CURRENT_SONG_DURATION, note.time + note.duration);\n        }\n        rootState.toneState.tone.Transport.schedule(() => {\n          commit(ADD_TIMER, new Timer(() => {\n            if (state.currentSong.fromPlaylist) {\n              rootState.toneState.sampler.triggerAttackRelease(note.name, note.duration, rootState.toneState.tone.now(), note.velocity);\n            }\n          }, rootState.canvasState.visualizeDelay));\n        }, note.time);\n        let index = null;\n        let forBlackNote = false;\n        for (let i = 0; i < rootState.keyboardState.notes.length; i++) {\n          if (rootState.keyboardState.notes[i].note === note.name) {\n            index = i;\n            break;\n          } else if (rootState.keyboardState.notes[i].blackNotes && rootState.keyboardState.notes[i].blackNote.note === note.name) {\n            index = i;\n            forBlackNote = true;\n            break;\n          }\n        }\n        rootState.toneState.tone.Transport.schedule(time => {\n          if (index != null) {\n            commit(ADD_TIMER, new Timer(() => {\n              commit(keyboardState + \"/\" + SET_KEY_PRESSED, {\n                index,\n                forBlackNote,\n                pressed: true\n              }, {\n                root: true\n              });\n            }, rootState.canvasState.waterfallDelay));\n            dispatch(canvasState + \"/\" + startDraw, {\n              noteName: note.name,\n              forBlackNote\n            }, {\n              root: true\n            });\n          }\n        }, note.time);\n        rootState.toneState.tone.Transport.schedule(time => {\n          if (index != null) {\n            commit(ADD_TIMER, new Timer(() => {\n              commit(keyboardState + \"/\" + SET_KEY_PRESSED, {\n                index,\n                forBlackNote,\n                pressed: false\n              }, {\n                root: true\n              });\n              rootState.toneState.sampler.triggerRelease(note.name);\n              if (lastSong && i === notes.length - 1) {\n                dispatch(stopPlaying, \"\");\n              }\n            }, rootState.canvasState.waterfallDelay));\n            dispatch(canvasState + \"/\" + stopDraw, {\n              noteName: note.name,\n              forBlackNote\n            }, {\n              root: true\n            });\n          }\n        }, note.time + note.duration);\n      });\n    },\n    [prepareSong]({\n      state,\n      dispatch\n    }) {\n      if (state.currentSong.fromPlaylist) {\n        Midi.fromUrl(SONGS_URL + state.currentSong.name + \".mid\").then(midi => {\n          midi.tracks.forEach((track, i) => dispatch(prepareNotes, {\n            notes: track.notes,\n            lastSong: midi.tracks.length == i + 1\n          }));\n        });\n      } else {\n        dispatch(prepareNotes, {\n          notes: state.currentSong.notes,\n          lastSong: true\n        });\n      }\n    },\n    [stopPlaying]({\n      dispatch,\n      rootState,\n      commit\n    }, currentSong) {\n      commit(SET_IS_LOADING, true);\n      dispatch(clearTimes);\n      commit(keyboardState + \"/\" + CLEAR_PRESSED_KEYS, {}, {\n        root: true\n      });\n      dispatch(menuState + \"/\" + stopPlaying, {}, {\n        root: true\n      });\n      setTimeout(() => {\n        rootState.toneState.tone.Transport.stop();\n        rootState.toneState.tone.Transport.cancel();\n        dispatch(changeSong, currentSong);\n        commit(SET_IS_LOADING, false);\n      }, 10);\n    }\n  }\n};","map":{"version":3,"names":["Midi","Timer","canvasState","keyboardState","menuState","SET_CURRENT_SONG","SET_CURRENT_SONG_DURATION","SET_IS_LOADING","ADD_NEW_RECORDED_SONG","ADD_TIMER","CLEAR_TIMERS","SET_KEY_PRESSED","CLEAR_PRESSED_KEYS","changeSong","clearTimes","pauseTimers","resumeTimers","prepareNotes","prepareSong","stopPlaying","startDraw","stopDraw","SONGS_URL","namespaced","state","songs","name","fromPlaylist","currentSong","timers","currentSongDuration","isLoading","mutations","val","unshift","timer","push","length","actions","commit","dispatch","forEach","pause","resume","rootState","notes","lastSong","note","i","time","duration","toneState","tone","Transport","schedule","sampler","triggerAttackRelease","now","velocity","visualizeDelay","index","forBlackNote","blackNotes","blackNote","pressed","root","waterfallDelay","noteName","triggerRelease","fromUrl","then","midi","tracks","track","setTimeout","stop","cancel"],"sources":["/Users/Sunhaoxiang/Desktop/IB_CS/CS_IA/src/store/modules/playlistState.js"],"sourcesContent":["import { Midi } from \"@tonejs/midi\"\nimport Timer  from \"../../utils/SetTimeoutTimer\"\nimport { canvasState, keyboardState, menuState } from \"@/store/consts/states.js\";\nimport { SET_CURRENT_SONG, \n    SET_CURRENT_SONG_DURATION,\n    SET_IS_LOADING,\n    ADD_NEW_RECORDED_SONG,\n    ADD_TIMER,\n    CLEAR_TIMERS,\n    SET_KEY_PRESSED,\n    CLEAR_PRESSED_KEYS,\n} from \"@/store/consts/mutation_types.js\";\nimport { changeSong, \n    clearTimes,\n    pauseTimers,\n    resumeTimers,\n    prepareNotes,\n    prepareSong,\n    stopPlaying,\n    startDraw,\n    stopDraw,\n    // uploadMIDI,\n    // deleteMIDI\n  } from \"@/store/consts/actions.js\";\n\nconst SONGS_URL = \"./songs/\";\n\nexport default {\n    namespaced: true,\n\n    state: {\n        songs: [\n            // {name: \"UPLOAD A NEW MIDI FILE\", fromPlaylist: true},\n            { name: \"J. Pachelbel - Canon in D\", fromPlaylist: true },\n           {name: \"Rick Astley - Never Gonna Give You Up\", fromPlaylist: true},\n        ],\n       currentSong: \"\",\n       timers : [],\n       currentSongDuration: 0,\n       isLoading : false,\n    },\n\n    mutations: {\n       [SET_CURRENT_SONG](state, val){\n            state.currentSong = val;\n       },\n       [SET_CURRENT_SONG_DURATION](state, val){\n            state.currentSongDuration = val;\n       },\n       [SET_IS_LOADING](state, val){\n           state.isLoading = val;\n       },\n       [ADD_NEW_RECORDED_SONG](state, val){\n           state.songs.unshift(val);\n       },\n       [ADD_TIMER](state, timer){\n           state.timers.push(timer);\n       },\n       [CLEAR_TIMERS](state){\n           state.timers.length = 0;\n        },\n        // [UPLOAD_SONG](state, val) {\n        //     state.songs.unshift(val);\n        // },\n        // [DELETE_SONG](state, val) {\n        //     idx = state.songs.indexOf(val);\n        //     state.songs.splice(idx, 1);\n        // }\n    },\n\n    actions: {\n        [changeSong]({ commit, dispatch }, currentSong) {\n            commit(SET_CURRENT_SONG, currentSong);\n            if (currentSong != \"\") {\n                dispatch(prepareSong);\n            }\n            // let flag = True\n            // while (flag == True) {\n            //     commit(SET_CURRENT_SONG, currentSong);\n            //     if(currentSong != \"\"){\n            //         dispatch(prepareSong);\n            //         flag = False\n            //     }\n            //     // else if (currentSong == \"UPLOAD A NEW MIDI FILE\") {\n                    \n            //     // }\n            // }\n        },\n\n        [clearTimes]({state, commit}){\n            state.timers.forEach(timer => timer.pause());\n            commit(CLEAR_TIMERS);\n        },\n\n        [pauseTimers]({state}){\n            state.timers.forEach(timer => timer.pause());\n        },\n\n        [resumeTimers]({state}){\n            state.timers.forEach(timer => timer.resume());\n        },\n\n        [prepareNotes]({state, rootState, commit, dispatch}, {notes, lastSong}) {\n            notes.forEach((note, i) => {\n                if(lastSong && i === notes.length - 1){\n                    commit(SET_CURRENT_SONG_DURATION, note.time + note.duration);\n                }\n                \n                rootState.toneState.tone.Transport.schedule(() => {\n                    commit(ADD_TIMER, new Timer(() => {\n                        \n                        if(state.currentSong.fromPlaylist){\n                            rootState.toneState.sampler.triggerAttackRelease(note.name, note.duration, rootState.toneState.tone.now(), note.velocity);\n                        }\n\n                    }, rootState.canvasState.visualizeDelay));\n              \n                }, note.time)\n      \n                let index = null;\n                let forBlackNote = false;\n                for (let i = 0; i < rootState.keyboardState.notes.length; i++) {\n                    if(rootState.keyboardState.notes[i].note === note.name){\n                      index = i;\n                      break;\n                    } \n                    else if(rootState.keyboardState.notes[i].blackNotes && rootState.keyboardState.notes[i].blackNote.note === note.name){\n                      index = i;\n                      forBlackNote = true;\n                      break;\n                    }\n                }\n       \n                rootState.toneState.tone.Transport.schedule(time => {\n                        if(index != null){\n                            commit(ADD_TIMER, new Timer(() => {\n                                commit(keyboardState + \"/\" + SET_KEY_PRESSED, {index, forBlackNote, pressed : true}, {root:true});\n                            }, rootState.canvasState.waterfallDelay));\n                            \n                            dispatch(canvasState + \"/\" + startDraw, {noteName : note.name, forBlackNote}, {root:true});\n                        }\n                }, note.time)\n      \n                rootState.toneState.tone.Transport.schedule(time => {\n                        if(index != null){\n                            commit(ADD_TIMER, new Timer(() => {\n\n                                commit(keyboardState + \"/\" + SET_KEY_PRESSED, {index, forBlackNote, pressed : false}, {root:true});\n                                rootState.toneState.sampler.triggerRelease(note.name);\n\n                                if(lastSong && i === notes.length - 1){\n                                    dispatch(stopPlaying, \"\");\n                                }\n\n                            }, rootState.canvasState.waterfallDelay));\n\n                            dispatch(canvasState + \"/\" + stopDraw, {noteName : note.name, forBlackNote}, {root:true});\n                        }\n                }, note.time + note.duration)\n      \n            })\n        },\n\n        [prepareSong]({state, dispatch}){\n            if(state.currentSong.fromPlaylist){\n                Midi.fromUrl(SONGS_URL + state.currentSong.name + \".mid\").then(midi => {\n                    midi.tracks.forEach((track, i) => dispatch(prepareNotes, {notes : track.notes, lastSong : midi.tracks.length == i + 1}));\n                });  \n            } else {\n                dispatch(prepareNotes, {notes:state.currentSong.notes, lastSong : true})\n            }\n        },\n\n        [stopPlaying]({dispatch, rootState, commit}, currentSong){\n            commit(SET_IS_LOADING, true);\n            dispatch(clearTimes);\n            commit(keyboardState + \"/\" + CLEAR_PRESSED_KEYS, {}, {root:true});\n            dispatch(menuState + \"/\" + stopPlaying, {}, {root:true});\n            \n            setTimeout(() => {\n                rootState.toneState.tone.Transport.stop();\n                rootState.toneState.tone.Transport.cancel();\n                dispatch(changeSong, currentSong);\n                commit(SET_IS_LOADING, false);\n            }, 10)\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}