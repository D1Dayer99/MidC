{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { playlistState, toneState } from \"@/store/consts/states.js\";\nimport { SET_RECORDER, SET_IS_RECORDING, SET_START_RECORD_TIME, SET_END_RECORD_TIME, SET_SAVE_RECORDING_DIALOG, ADD_RECORD_MIDI, ADD_RECORD_AUDIO, ADD_RECORD_MAP, CLEAR_RECORD_MIDI, CLEAR_RECORD_AUDIO, CALCULATE_DURATION_AND_TIME_MIDI, ADD_NEW_RECORDED_SONG } from \"@/store/consts/mutation_types.js\";\nimport { createRecorder, recordMidiNote, startRecording, stopRecording, saveSong, connectSampler } from \"@/store/consts/actions.js\";\nexport default {\n  namespaced: true,\n  state: {\n    recorder: {},\n    recordedAudioChunks: [],\n    recordingHelperMap: {},\n    recordedMidiChunks: [],\n    startRecordTime: 0,\n    endRecordTime: 0,\n    isRecording: false,\n    saveRecordingDialog: false\n  },\n  mutations: {\n    [SET_RECORDER](state, val) {\n      state.recorder = val;\n    },\n    [SET_IS_RECORDING](state, val) {\n      state.isRecording = val;\n    },\n    [SET_START_RECORD_TIME](state, val) {\n      state.startRecordTime = val;\n    },\n    [SET_END_RECORD_TIME](state, val) {\n      state.endRecordTime = val;\n    },\n    [SET_SAVE_RECORDING_DIALOG](state, val) {\n      state.saveRecordingDialog = val;\n    },\n    [ADD_RECORD_MIDI](state, note) {\n      if (state.recordingHelperMap[note] != undefined) {\n        state.recordedMidiChunks.push({\n          name: state.recordingHelperMap[note].name,\n          startTime: state.recordingHelperMap[note].startTime,\n          endTime: new Date().getTime()\n        });\n        delete state.recordingHelperMap[note];\n      }\n    },\n    [ADD_RECORD_AUDIO](state, val) {\n      state.recordedAudioChunks.push(val);\n    },\n    [ADD_RECORD_MAP](state, note) {\n      state.recordingHelperMap[note] = {\n        name: note,\n        startTime: new Date().getTime(),\n        endTime: null\n      };\n    },\n    [CLEAR_RECORD_MIDI](state) {\n      state.recordedMidiChunks.length = 0;\n    },\n    [CLEAR_RECORD_AUDIO](state) {\n      state.recordedAudioChunks.length = 0;\n    },\n    [CALCULATE_DURATION_AND_TIME_MIDI](state) {\n      if (state.recordedMidiChunks.length != 0) {\n        state.recordedMidiChunks[0].time = state.recordedMidiChunks[0].startTime - state.startRecordTime;\n        state.recordedMidiChunks[0].duration = state.recordedMidiChunks[0].endTime - state.recordedMidiChunks[0].startTime;\n        for (let i = 1; i < state.recordedMidiChunks.length; i++) {\n          state.recordedMidiChunks[i].time = state.recordedMidiChunks[i - 1].time + state.recordedMidiChunks[i].startTime - state.recordedMidiChunks[i - 1].startTime;\n          state.recordedMidiChunks[i].duration = state.recordedMidiChunks[i].endTime - state.recordedMidiChunks[i].startTime;\n        }\n        for (let i = 0; i < state.recordedMidiChunks.length; i++) {\n          state.recordedMidiChunks[i].time /= 1000;\n          state.recordedMidiChunks[i].duration /= 1000;\n        }\n      }\n    }\n  },\n  actions: {\n    [createRecorder]({\n      rootState,\n      commit,\n      dispatch\n    }) {\n      const dest = rootState.toneState.tone.context.createMediaStreamDestination();\n      commit(SET_RECORDER, new MediaRecorder(dest.stream));\n      dispatch(toneState + \"/\" + connectSampler, dest, {\n        root: true\n      });\n    },\n    [recordMidiNote]({\n      commit\n    }, note) {\n      commit(ADD_RECORD_MAP, note);\n    },\n    [startRecording]({\n      commit,\n      state\n    }) {\n      commit(CLEAR_RECORD_MIDI);\n      commit(CLEAR_RECORD_AUDIO);\n      state.recorder.start();\n      state.recorder.ondataavailable = e => state.recordedAudioChunks.push(e.data);\n      commit(SET_IS_RECORDING, true);\n      commit(SET_START_RECORD_TIME, new Date().getTime());\n    },\n    [stopRecording]({\n      commit,\n      state\n    }) {\n      state.recorder.stop();\n      state.recorder.onstop = e => {\n        let blob = new Blob(state.recordedAudioChunks, {\n          type: 'audio/ogg; codecs=opus'\n        });\n        document.querySelector('audio').src = URL.createObjectURL(blob);\n      };\n      commit(SET_IS_RECORDING, false);\n      commit(SET_END_RECORD_TIME, new Date().getTime());\n      commit(CALCULATE_DURATION_AND_TIME_MIDI);\n      commit(SET_SAVE_RECORDING_DIALOG, true);\n      commit(playlistState + \"/\" + \"SET_CURRENT_SONG\", \"\", {\n        root: true\n      });\n    },\n    [saveSong]({\n      state,\n      commit\n    }, songName) {\n      const newSong = {\n        name: songName,\n        notes: Array.from(state.recordedMidiChunks),\n        forPlaylist: false\n      };\n      commit(playlistState + \"/\" + ADD_NEW_RECORDED_SONG, newSong, {\n        root: true\n      });\n      commit(SET_SAVE_RECORDING_DIALOG, false);\n    }\n  }\n};","map":{"version":3,"names":["playlistState","toneState","SET_RECORDER","SET_IS_RECORDING","SET_START_RECORD_TIME","SET_END_RECORD_TIME","SET_SAVE_RECORDING_DIALOG","ADD_RECORD_MIDI","ADD_RECORD_AUDIO","ADD_RECORD_MAP","CLEAR_RECORD_MIDI","CLEAR_RECORD_AUDIO","CALCULATE_DURATION_AND_TIME_MIDI","ADD_NEW_RECORDED_SONG","createRecorder","recordMidiNote","startRecording","stopRecording","saveSong","connectSampler","namespaced","state","recorder","recordedAudioChunks","recordingHelperMap","recordedMidiChunks","startRecordTime","endRecordTime","isRecording","saveRecordingDialog","mutations","val","note","undefined","push","name","startTime","endTime","Date","getTime","length","time","duration","i","actions","rootState","commit","dispatch","dest","tone","context","createMediaStreamDestination","MediaRecorder","stream","root","start","ondataavailable","e","data","stop","onstop","blob","Blob","type","document","querySelector","src","URL","createObjectURL","songName","newSong","notes","Array","from","forPlaylist"],"sources":["/Users/Sunhaoxiang/Desktop/IB_CS/Final_Holder/Product/CS_IA/src/store/modules/recordingState.js"],"sourcesContent":["import { playlistState, toneState } from \"@/store/consts/states.js\";\nimport { SET_RECORDER, \n    SET_IS_RECORDING,\n    SET_START_RECORD_TIME,\n    SET_END_RECORD_TIME,\n    SET_SAVE_RECORDING_DIALOG,\n    ADD_RECORD_MIDI,\n    ADD_RECORD_AUDIO,\n    ADD_RECORD_MAP,\n    CLEAR_RECORD_MIDI,\n    CLEAR_RECORD_AUDIO,\n    CALCULATE_DURATION_AND_TIME_MIDI,\n    ADD_NEW_RECORDED_SONG\n} from \"@/store/consts/mutation_types.js\";\nimport { createRecorder, \n    recordMidiNote,\n    startRecording,\n    stopRecording,\n    saveSong,\n    connectSampler\n} from \"@/store/consts/actions.js\";\n\nexport default {\n    namespaced: true,\n\n    state: {\n    recorder: {},\n    recordedAudioChunks: [],\n    recordingHelperMap: {},\n    recordedMidiChunks: [],\n    startRecordTime: 0,\n    endRecordTime: 0,\n    isRecording: false,\n    saveRecordingDialog: false,\n    },\n\n    mutations: {\n        [SET_RECORDER](state, val){\n            state.recorder = val;\n        },\n        [SET_IS_RECORDING](state, val){\n            state.isRecording = val;\n        },\n        [SET_START_RECORD_TIME](state, val){\n            state.startRecordTime = val;\n        },\n        [SET_END_RECORD_TIME](state, val){\n            state.endRecordTime = val;\n        },\n        [SET_SAVE_RECORDING_DIALOG](state, val){\n            state.saveRecordingDialog = val;\n        },\n        [ADD_RECORD_MIDI](state, note){\n            if(state.recordingHelperMap[note] != undefined) {\n                state.recordedMidiChunks.push({\n                    name : state.recordingHelperMap[note].name,\n                    startTime : state.recordingHelperMap[note].startTime,\n                    endTime : new Date().getTime()\n                });\n\n                delete state.recordingHelperMap[note];\n            }\n        },\n        [ADD_RECORD_AUDIO](state, val){\n            state.recordedAudioChunks.push(val);\n        },\n        [ADD_RECORD_MAP](state, note){\n            state.recordingHelperMap[note] = {\n                name: note,\n                startTime : new Date().getTime(),\n                endTime : null\n            };\n        },\n        [CLEAR_RECORD_MIDI](state){\n            state.recordedMidiChunks.length = 0;\n        },\n        [CLEAR_RECORD_AUDIO](state){\n            state.recordedAudioChunks.length = 0;\n        },\n        [CALCULATE_DURATION_AND_TIME_MIDI](state){\n            if(state.recordedMidiChunks.length != 0){\n            \n                state.recordedMidiChunks[0].time = state.recordedMidiChunks[0].startTime - state.startRecordTime;\n                state.recordedMidiChunks[0].duration = state.recordedMidiChunks[0].endTime - state.recordedMidiChunks[0].startTime;\n    \n                for(let i = 1; i < state.recordedMidiChunks.length; i++){\n                    state.recordedMidiChunks[i].time = state.recordedMidiChunks[i - 1].time + \n                                                        state.recordedMidiChunks[i].startTime - \n                                                        state.recordedMidiChunks[i - 1].startTime\n                    state.recordedMidiChunks[i].duration = state.recordedMidiChunks[i].endTime - state.recordedMidiChunks[i].startTime;\n                }\n\n                for(let i = 0; i < state.recordedMidiChunks.length; i++){\n                    state.recordedMidiChunks[i].time /= 1000;\n                    state.recordedMidiChunks[i].duration /= 1000;\n                }\n            }\n        },\n    },\n\n    actions: {\n        [createRecorder]({ rootState, commit, dispatch }){\n            const dest  = rootState.toneState.tone.context.createMediaStreamDestination();\n            commit(SET_RECORDER, new MediaRecorder(dest.stream));\n            dispatch(toneState + \"/\" + connectSampler, dest, {root:true});\n        },\n\n        [recordMidiNote]({ commit }, note) {\n            commit(ADD_RECORD_MAP, note);\n        },\n\n        [startRecording]({ commit, state }){\n            commit(CLEAR_RECORD_MIDI);\n            commit(CLEAR_RECORD_AUDIO);\n\n            state.recorder.start();\n            state.recorder.ondataavailable = e => state.recordedAudioChunks.push(e.data);\n\n            commit(SET_IS_RECORDING, true);\n            commit(SET_START_RECORD_TIME, new Date().getTime());\n        },\n\n        [stopRecording]({ commit, state }){\n            state.recorder.stop();\n            state.recorder.onstop = e => {\n                let blob = new Blob(state.recordedAudioChunks, { type: 'audio/ogg; codecs=opus' });\n                document.querySelector('audio').src = URL.createObjectURL(blob);\n            };\n\n            commit(SET_IS_RECORDING, false);\n            commit(SET_END_RECORD_TIME, new Date().getTime());\n            commit(CALCULATE_DURATION_AND_TIME_MIDI);\n            commit(SET_SAVE_RECORDING_DIALOG, true);\n            commit(playlistState + \"/\" + \"SET_CURRENT_SONG\", \"\", {root:true});\n        },\n\n        [saveSong]({state, commit}, songName){\n            const newSong = {\n                name : songName,\n                notes : Array.from(state.recordedMidiChunks),\n                forPlaylist: false\n            };\n    \n            commit(playlistState + \"/\" + ADD_NEW_RECORDED_SONG, newSong, {root:true});\n            commit(SET_SAVE_RECORDING_DIALOG, false);\n        }\n    }\n}\n"],"mappings":";AAAA,SAASA,aAAa,EAAEC,SAAS,QAAQ,0BAA0B;AACnE,SAASC,YAAY,EACjBC,gBAAgB,EAChBC,qBAAqB,EACrBC,mBAAmB,EACnBC,yBAAyB,EACzBC,eAAe,EACfC,gBAAgB,EAChBC,cAAc,EACdC,iBAAiB,EACjBC,kBAAkB,EAClBC,gCAAgC,EAChCC,qBAAqB,QAClB,kCAAkC;AACzC,SAASC,cAAc,EACnBC,cAAc,EACdC,cAAc,EACdC,aAAa,EACbC,QAAQ,EACRC,cAAc,QACX,2BAA2B;AAElC,eAAe;EACXC,UAAU,EAAE,IAAI;EAEhBC,KAAK,EAAE;IACPC,QAAQ,EAAE,CAAC,CAAC;IACZC,mBAAmB,EAAE,EAAE;IACvBC,kBAAkB,EAAE,CAAC,CAAC;IACtBC,kBAAkB,EAAE,EAAE;IACtBC,eAAe,EAAE,CAAC;IAClBC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,KAAK;IAClBC,mBAAmB,EAAE;EACrB,CAAC;EAEDC,SAAS,EAAE;IACP,CAAC5B,YAAY,EAAEmB,KAAK,EAAEU,GAAG,EAAC;MACtBV,KAAK,CAACC,QAAQ,GAAGS,GAAG;IACxB,CAAC;IACD,CAAC5B,gBAAgB,EAAEkB,KAAK,EAAEU,GAAG,EAAC;MAC1BV,KAAK,CAACO,WAAW,GAAGG,GAAG;IAC3B,CAAC;IACD,CAAC3B,qBAAqB,EAAEiB,KAAK,EAAEU,GAAG,EAAC;MAC/BV,KAAK,CAACK,eAAe,GAAGK,GAAG;IAC/B,CAAC;IACD,CAAC1B,mBAAmB,EAAEgB,KAAK,EAAEU,GAAG,EAAC;MAC7BV,KAAK,CAACM,aAAa,GAAGI,GAAG;IAC7B,CAAC;IACD,CAACzB,yBAAyB,EAAEe,KAAK,EAAEU,GAAG,EAAC;MACnCV,KAAK,CAACQ,mBAAmB,GAAGE,GAAG;IACnC,CAAC;IACD,CAACxB,eAAe,EAAEc,KAAK,EAAEW,IAAI,EAAC;MAC1B,IAAGX,KAAK,CAACG,kBAAkB,CAACQ,IAAI,CAAC,IAAIC,SAAS,EAAE;QAC5CZ,KAAK,CAACI,kBAAkB,CAACS,IAAI,CAAC;UAC1BC,IAAI,EAAGd,KAAK,CAACG,kBAAkB,CAACQ,IAAI,CAAC,CAACG,IAAI;UAC1CC,SAAS,EAAGf,KAAK,CAACG,kBAAkB,CAACQ,IAAI,CAAC,CAACI,SAAS;UACpDC,OAAO,EAAG,IAAIC,IAAI,EAAE,CAACC,OAAO;QAChC,CAAC,CAAC;QAEF,OAAOlB,KAAK,CAACG,kBAAkB,CAACQ,IAAI,CAAC;MACzC;IACJ,CAAC;IACD,CAACxB,gBAAgB,EAAEa,KAAK,EAAEU,GAAG,EAAC;MAC1BV,KAAK,CAACE,mBAAmB,CAACW,IAAI,CAACH,GAAG,CAAC;IACvC,CAAC;IACD,CAACtB,cAAc,EAAEY,KAAK,EAAEW,IAAI,EAAC;MACzBX,KAAK,CAACG,kBAAkB,CAACQ,IAAI,CAAC,GAAG;QAC7BG,IAAI,EAAEH,IAAI;QACVI,SAAS,EAAG,IAAIE,IAAI,EAAE,CAACC,OAAO,EAAE;QAChCF,OAAO,EAAG;MACd,CAAC;IACL,CAAC;IACD,CAAC3B,iBAAiB,EAAEW,KAAK,EAAC;MACtBA,KAAK,CAACI,kBAAkB,CAACe,MAAM,GAAG,CAAC;IACvC,CAAC;IACD,CAAC7B,kBAAkB,EAAEU,KAAK,EAAC;MACvBA,KAAK,CAACE,mBAAmB,CAACiB,MAAM,GAAG,CAAC;IACxC,CAAC;IACD,CAAC5B,gCAAgC,EAAES,KAAK,EAAC;MACrC,IAAGA,KAAK,CAACI,kBAAkB,CAACe,MAAM,IAAI,CAAC,EAAC;QAEpCnB,KAAK,CAACI,kBAAkB,CAAC,CAAC,CAAC,CAACgB,IAAI,GAAGpB,KAAK,CAACI,kBAAkB,CAAC,CAAC,CAAC,CAACW,SAAS,GAAGf,KAAK,CAACK,eAAe;QAChGL,KAAK,CAACI,kBAAkB,CAAC,CAAC,CAAC,CAACiB,QAAQ,GAAGrB,KAAK,CAACI,kBAAkB,CAAC,CAAC,CAAC,CAACY,OAAO,GAAGhB,KAAK,CAACI,kBAAkB,CAAC,CAAC,CAAC,CAACW,SAAS;QAElH,KAAI,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtB,KAAK,CAACI,kBAAkB,CAACe,MAAM,EAAEG,CAAC,EAAE,EAAC;UACpDtB,KAAK,CAACI,kBAAkB,CAACkB,CAAC,CAAC,CAACF,IAAI,GAAGpB,KAAK,CAACI,kBAAkB,CAACkB,CAAC,GAAG,CAAC,CAAC,CAACF,IAAI,GACnCpB,KAAK,CAACI,kBAAkB,CAACkB,CAAC,CAAC,CAACP,SAAS,GACrCf,KAAK,CAACI,kBAAkB,CAACkB,CAAC,GAAG,CAAC,CAAC,CAACP,SAAS;UAC7Ef,KAAK,CAACI,kBAAkB,CAACkB,CAAC,CAAC,CAACD,QAAQ,GAAGrB,KAAK,CAACI,kBAAkB,CAACkB,CAAC,CAAC,CAACN,OAAO,GAAGhB,KAAK,CAACI,kBAAkB,CAACkB,CAAC,CAAC,CAACP,SAAS;QACtH;QAEA,KAAI,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtB,KAAK,CAACI,kBAAkB,CAACe,MAAM,EAAEG,CAAC,EAAE,EAAC;UACpDtB,KAAK,CAACI,kBAAkB,CAACkB,CAAC,CAAC,CAACF,IAAI,IAAI,IAAI;UACxCpB,KAAK,CAACI,kBAAkB,CAACkB,CAAC,CAAC,CAACD,QAAQ,IAAI,IAAI;QAChD;MACJ;IACJ;EACJ,CAAC;EAEDE,OAAO,EAAE;IACL,CAAC9B,cAAc,EAAE;MAAE+B,SAAS;MAAEC,MAAM;MAAEC;IAAS,CAAC,EAAC;MAC7C,MAAMC,IAAI,GAAIH,SAAS,CAAC5C,SAAS,CAACgD,IAAI,CAACC,OAAO,CAACC,4BAA4B,EAAE;MAC7EL,MAAM,CAAC5C,YAAY,EAAE,IAAIkD,aAAa,CAACJ,IAAI,CAACK,MAAM,CAAC,CAAC;MACpDN,QAAQ,CAAC9C,SAAS,GAAG,GAAG,GAAGkB,cAAc,EAAE6B,IAAI,EAAE;QAACM,IAAI,EAAC;MAAI,CAAC,CAAC;IACjE,CAAC;IAED,CAACvC,cAAc,EAAE;MAAE+B;IAAO,CAAC,EAAEd,IAAI,EAAE;MAC/Bc,MAAM,CAACrC,cAAc,EAAEuB,IAAI,CAAC;IAChC,CAAC;IAED,CAAChB,cAAc,EAAE;MAAE8B,MAAM;MAAEzB;IAAM,CAAC,EAAC;MAC/ByB,MAAM,CAACpC,iBAAiB,CAAC;MACzBoC,MAAM,CAACnC,kBAAkB,CAAC;MAE1BU,KAAK,CAACC,QAAQ,CAACiC,KAAK,EAAE;MACtBlC,KAAK,CAACC,QAAQ,CAACkC,eAAe,GAAGC,CAAC,IAAIpC,KAAK,CAACE,mBAAmB,CAACW,IAAI,CAACuB,CAAC,CAACC,IAAI,CAAC;MAE5EZ,MAAM,CAAC3C,gBAAgB,EAAE,IAAI,CAAC;MAC9B2C,MAAM,CAAC1C,qBAAqB,EAAE,IAAIkC,IAAI,EAAE,CAACC,OAAO,EAAE,CAAC;IACvD,CAAC;IAED,CAACtB,aAAa,EAAE;MAAE6B,MAAM;MAAEzB;IAAM,CAAC,EAAC;MAC9BA,KAAK,CAACC,QAAQ,CAACqC,IAAI,EAAE;MACrBtC,KAAK,CAACC,QAAQ,CAACsC,MAAM,GAAGH,CAAC,IAAI;QACzB,IAAII,IAAI,GAAG,IAAIC,IAAI,CAACzC,KAAK,CAACE,mBAAmB,EAAE;UAAEwC,IAAI,EAAE;QAAyB,CAAC,CAAC;QAClFC,QAAQ,CAACC,aAAa,CAAC,OAAO,CAAC,CAACC,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACP,IAAI,CAAC;MACnE,CAAC;MAEDf,MAAM,CAAC3C,gBAAgB,EAAE,KAAK,CAAC;MAC/B2C,MAAM,CAACzC,mBAAmB,EAAE,IAAIiC,IAAI,EAAE,CAACC,OAAO,EAAE,CAAC;MACjDO,MAAM,CAAClC,gCAAgC,CAAC;MACxCkC,MAAM,CAACxC,yBAAyB,EAAE,IAAI,CAAC;MACvCwC,MAAM,CAAC9C,aAAa,GAAG,GAAG,GAAG,kBAAkB,EAAE,EAAE,EAAE;QAACsD,IAAI,EAAC;MAAI,CAAC,CAAC;IACrE,CAAC;IAED,CAACpC,QAAQ,EAAE;MAACG,KAAK;MAAEyB;IAAM,CAAC,EAAEuB,QAAQ,EAAC;MACjC,MAAMC,OAAO,GAAG;QACZnC,IAAI,EAAGkC,QAAQ;QACfE,KAAK,EAAGC,KAAK,CAACC,IAAI,CAACpD,KAAK,CAACI,kBAAkB,CAAC;QAC5CiD,WAAW,EAAE;MACjB,CAAC;MAED5B,MAAM,CAAC9C,aAAa,GAAG,GAAG,GAAGa,qBAAqB,EAAEyD,OAAO,EAAE;QAAChB,IAAI,EAAC;MAAI,CAAC,CAAC;MACzER,MAAM,CAACxC,yBAAyB,EAAE,KAAK,CAAC;IAC5C;EACJ;AACJ,CAAC"},"metadata":{},"sourceType":"module"}