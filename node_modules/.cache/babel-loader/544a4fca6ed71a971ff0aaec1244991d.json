{"ast":null,"code":"import \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { Midi } from \"@tonejs/midi\";\nimport Timer from \"../../utils/SetTimeoutTimer\";\nimport { canvasState, keyboardState, menuState } from \"@/store/consts/states.js\";\nimport { SET_CURRENT_SONG, SET_CURRENT_SONG_DURATION, SET_IS_LOADING, ADD_NEW_RECORDED_SONG, ADD_TIMER, CLEAR_TIMERS, SET_NOTE_PRESSED, CLEAR_PRESSED_KEYS } from \"@/store/consts/mutations.js\";\nimport { changeSong, clearTimes, pauseTimers, resumeTimers, prepareNotes, prepareSong, stopPlaying, startDrawNote, stopDrawNote } from \"@/store/consts/actions.js\";\nconst SONGS_URL = \"./songs/\";\nexport default {\n  namespaced: true,\n  state: {\n    songs: [{\n      name: \"J. Pachelbel - Canon in D\",\n      fromPlaylist: true\n    }],\n    currentSong: \"\",\n    timers: [],\n    currentSongDuration: 0,\n    isLoading: false\n  },\n  mutations: {\n    [SET_CURRENT_SONG](state, val) {\n      state.currentSong = val;\n    },\n    [SET_CURRENT_SONG_DURATION](state, val) {\n      state.currentSongDuration = val;\n    },\n    [SET_IS_LOADING](state, val) {\n      state.isLoading = val;\n    },\n    [ADD_NEW_RECORDED_SONG](state, val) {\n      state.songs.unshift(val);\n    },\n    [ADD_TIMER](state, timer) {\n      state.timers.push(timer);\n    },\n    [CLEAR_TIMERS](state) {\n      state.timers.length = 0;\n    }\n  },\n  actions: {\n    [changeSong]({\n      commit,\n      dispatch\n    }, currentSong) {\n      commit(SET_CURRENT_SONG, currentSong);\n      if (currentSong != \"\") {\n        dispatch(prepareSong);\n      }\n    },\n    [clearTimes]({\n      state,\n      commit\n    }) {\n      state.timers.forEach(timer => timer.pause());\n      commit(CLEAR_TIMERS);\n    },\n    [pauseTimers]({\n      state\n    }) {\n      state.timers.forEach(timer => timer.pause());\n    },\n    [resumeTimers]({\n      state\n    }) {\n      state.timers.forEach(timer => timer.resume());\n    },\n    [prepareNotes]({\n      state,\n      rootState,\n      commit,\n      dispatch\n    }, {\n      notes,\n      lastSong\n    }) {\n      notes.forEach((note, i) => {\n        if (lastSong && i === notes.length - 1) {\n          commit(SET_CURRENT_SONG_DURATION, note.time + note.duration);\n        }\n        rootState.toneState.tone.Transport.schedule(() => {\n          commit(ADD_TIMER, new Timer(() => {\n            if (state.currentSong.fromPlaylist) {\n              rootState.toneState.sampler.triggerAttackRelease(note.name, note.duration, rootState.toneState.tone.now(), note.velocity);\n            } else {\n              if (rootState.menuState.sustain == false) {\n                rootState.toneState.sampler.triggerAttack(note.name);\n              } else {\n                rootState.toneState.sampler.triggerAttackRelease(note.name, \"2n\", rootState.toneState.tone.now());\n              }\n            }\n          }, rootState.canvasState.falling_blocks_delay));\n        }, note.time);\n        let index = null;\n        let forBlackNote = false;\n        for (let i = 0; i < rootState.keyboardState.notes.length; i++) {\n          if (rootState.keyboardState.notes[i].note === note.name) {\n            index = i;\n            break;\n          } else if (rootState.keyboardState.notes[i].blackNote && rootState.keyboardState.notes[i].blackNote.note === note.name) {\n            index = i;\n            forBlackNote = true;\n            break;\n          }\n        }\n        rootState.toneState.tone.Transport.schedule(time => {\n          // rootState.toneState.tone.Draw.schedule(() => {\n          if (index != null) {\n            commit(ADD_TIMER, new Timer(() => {\n              commit(keyboardState + \"/\" + SET_NOTE_PRESSED, {\n                index,\n                forBlackNote,\n                pressed: true\n              }, {\n                root: true\n              });\n            }, rootState.canvasState.falling_blocks_delay));\n            dispatch(canvasState + \"/\" + startDrawNote, {\n              noteName: note.name,\n              forBlackNote\n            }, {\n              root: true\n            });\n          }\n          // }, time)\n        }, note.time);\n        rootState.toneState.tone.Transport.schedule(time => {\n          // rootState.toneState.tone.Draw.schedule(() => {\n          if (index != null) {\n            commit(ADD_TIMER, new Timer(() => {\n              commit(keyboardState + \"/\" + SET_NOTE_PRESSED, {\n                index,\n                forBlackNote,\n                pressed: false\n              }, {\n                root: true\n              });\n              if (rootState.menuState.sustain == false) {\n                rootState.toneState.sampler.triggerRelease(note.name);\n              }\n              if (lastSong && i === notes.length - 1) {\n                dispatch(stopPlaying, \"\");\n              }\n            }, rootState.canvasState.falling_blocks_delay));\n            dispatch(canvasState + \"/\" + stopDrawNote, {\n              noteName: note.name,\n              forBlackNote\n            }, {\n              root: true\n            });\n          }\n          // }, time)\n        }, note.time + note.duration);\n      });\n    },\n    [prepareSong]({\n      state,\n      dispatch\n    }) {\n      if (state.currentSong.fromPlaylist) {\n        Midi.fromUrl(SONGS_URL + state.currentSong.name + \".mid\").then(midi => {\n          midi.tracks.forEach((track, i) => dispatch(prepareNotes, {\n            notes: track.notes,\n            lastSong: midi.tracks.length == i + 1\n          }));\n        });\n      } else {\n        dispatch(prepareNotes, {\n          notes: state.currentSong.notes,\n          lastSong: true\n        });\n      }\n    },\n    [stopPlaying]({\n      dispatch,\n      rootState,\n      commit\n    }, currentSong) {\n      commit(SET_IS_LOADING, true);\n      dispatch(clearTimes);\n      commit(keyboardState + \"/\" + CLEAR_PRESSED_KEYS, {}, {\n        root: true\n      });\n      dispatch(menuState + \"/\" + stopPlaying, {}, {\n        root: true\n      });\n      setTimeout(() => {\n        rootState.toneState.tone.Transport.stop();\n        rootState.toneState.tone.Transport.cancel();\n        dispatch(changeSong, currentSong);\n        commit(SET_IS_LOADING, false);\n      }, 10);\n    }\n  }\n};","map":{"version":3,"names":["Midi","Timer","canvasState","keyboardState","menuState","SET_CURRENT_SONG","SET_CURRENT_SONG_DURATION","SET_IS_LOADING","ADD_NEW_RECORDED_SONG","ADD_TIMER","CLEAR_TIMERS","SET_NOTE_PRESSED","CLEAR_PRESSED_KEYS","changeSong","clearTimes","pauseTimers","resumeTimers","prepareNotes","prepareSong","stopPlaying","startDrawNote","stopDrawNote","SONGS_URL","namespaced","state","songs","name","fromPlaylist","currentSong","timers","currentSongDuration","isLoading","mutations","val","unshift","timer","push","length","actions","commit","dispatch","forEach","pause","resume","rootState","notes","lastSong","note","i","time","duration","toneState","tone","Transport","schedule","sampler","triggerAttackRelease","now","velocity","sustain","triggerAttack","falling_blocks_delay","index","forBlackNote","blackNote","pressed","root","noteName","triggerRelease","fromUrl","then","midi","tracks","track","setTimeout","stop","cancel"],"sources":["/Users/Sunhaoxiang/Desktop/IB_CS/CS_IA/src/store/modules/playlistState.js"],"sourcesContent":["import { Midi } from \"@tonejs/midi\"\nimport Timer  from \"../../utils/SetTimeoutTimer\"\nimport { canvasState, keyboardState, menuState } from \"@/store/consts/states.js\";\nimport { SET_CURRENT_SONG, \n    SET_CURRENT_SONG_DURATION,\n    SET_IS_LOADING,\n    ADD_NEW_RECORDED_SONG,\n    ADD_TIMER,\n    CLEAR_TIMERS,\n    SET_NOTE_PRESSED,\n    CLEAR_PRESSED_KEYS\n} from \"@/store/consts/mutations.js\";\nimport { changeSong, \n    clearTimes,\n    pauseTimers,\n    resumeTimers,\n    prepareNotes,\n    prepareSong,\n    stopPlaying,\n    startDrawNote,\n    stopDrawNote,\n  } from \"@/store/consts/actions.js\";\n\nconst SONGS_URL = \"./songs/\";\n\nexport default {\n    namespaced: true,\n\n    state: {\n       songs:[\n           {name : \"J. Pachelbel - Canon in D\", fromPlaylist: true },\n        ],\n       currentSong: \"\",\n       timers : [],\n       currentSongDuration: 0,\n       isLoading : false,\n    },\n\n    mutations: {\n       [SET_CURRENT_SONG](state, val){\n            state.currentSong = val;\n       },\n       [SET_CURRENT_SONG_DURATION](state, val){\n            state.currentSongDuration = val;\n       },\n       [SET_IS_LOADING](state, val){\n           state.isLoading = val;\n       },\n       [ADD_NEW_RECORDED_SONG](state, val){\n           state.songs.unshift(val);\n       },\n       [ADD_TIMER](state, timer){\n           state.timers.push(timer);\n       },\n       [CLEAR_TIMERS](state){\n           state.timers.length = 0;\n       }\n    },\n\n    actions: {\n        [changeSong]({commit, dispatch}, currentSong) {\n            commit(SET_CURRENT_SONG, currentSong);\n            if(currentSong != \"\"){\n                dispatch(prepareSong);\n            }\n        },\n\n        [clearTimes]({state, commit}){\n            state.timers.forEach(timer => timer.pause());\n            commit(CLEAR_TIMERS);\n        },\n\n        [pauseTimers]({state}){\n            state.timers.forEach(timer => timer.pause());\n        },\n\n        [resumeTimers]({state}){\n            state.timers.forEach(timer => timer.resume());\n        },\n\n        [prepareNotes]({state, rootState, commit, dispatch}, {notes, lastSong}) {\n            notes.forEach((note, i) => {\n                if(lastSong && i === notes.length - 1){\n                    commit(SET_CURRENT_SONG_DURATION, note.time + note.duration);\n                }\n                \n                rootState.toneState.tone.Transport.schedule(() => {\n                    commit(ADD_TIMER, new Timer(() => {\n                        \n                        if(state.currentSong.fromPlaylist){\n                            rootState.toneState.sampler.triggerAttackRelease(note.name, note.duration, rootState.toneState.tone.now(), note.velocity);\n                        } else {\n                            if(rootState.menuState.sustain == false){\n                                rootState.toneState.sampler.triggerAttack(note.name);\n                            } else {\n                                rootState.toneState.sampler.triggerAttackRelease(note.name, \"2n\", rootState.toneState.tone.now());\n                            }\n                        }\n\n                    }, rootState.canvasState.falling_blocks_delay));\n              \n                }, note.time)\n      \n                let index = null;\n                let forBlackNote = false;\n                for (let i = 0; i < rootState.keyboardState.notes.length; i++) {\n                    if(rootState.keyboardState.notes[i].note === note.name){\n                      index = i;\n                      break;\n                    } \n                    else if(rootState.keyboardState.notes[i].blackNote && rootState.keyboardState.notes[i].blackNote.note === note.name){\n                      index = i;\n                      forBlackNote = true;\n                      break;\n                    }\n                }\n       \n                rootState.toneState.tone.Transport.schedule(time => {\n                    // rootState.toneState.tone.Draw.schedule(() => {\n                        if(index != null){\n                            commit(ADD_TIMER, new Timer(() => {\n                                commit(keyboardState + \"/\" + SET_NOTE_PRESSED, {index, forBlackNote, pressed : true}, {root:true});\n                            }, rootState.canvasState.falling_blocks_delay));\n                            \n                            dispatch(canvasState + \"/\" + startDrawNote, {noteName : note.name, forBlackNote}, {root:true});\n                        }\n                    // }, time)\n                }, note.time)\n      \n                rootState.toneState.tone.Transport.schedule(time => {\n                    // rootState.toneState.tone.Draw.schedule(() => {\n                        if(index != null){\n                            commit(ADD_TIMER, new Timer(() => {\n\n                                commit(keyboardState + \"/\" + SET_NOTE_PRESSED, {index, forBlackNote, pressed : false}, {root:true});\n\n                                if(rootState.menuState.sustain == false){\n                                    rootState.toneState.sampler.triggerRelease(note.name);\n                                }\n\n                                if(lastSong && i === notes.length - 1){\n                                    dispatch(stopPlaying, \"\");\n                                }\n\n                            }, rootState.canvasState.falling_blocks_delay));\n\n                            dispatch(canvasState + \"/\" + stopDrawNote, {noteName : note.name, forBlackNote}, {root:true});\n                        }\n                    // }, time)\n                }, note.time + note.duration)\n      \n            })\n        },\n\n        [prepareSong]({state, dispatch}){\n            if(state.currentSong.fromPlaylist){\n                Midi.fromUrl(SONGS_URL + state.currentSong.name + \".mid\").then(midi => {\n                    midi.tracks.forEach((track, i) => dispatch(prepareNotes, {notes : track.notes, lastSong : midi.tracks.length == i + 1}));\n                });  \n            } else {\n                dispatch(prepareNotes, {notes:state.currentSong.notes, lastSong : true})\n            }\n        },\n\n        [stopPlaying]({dispatch, rootState, commit}, currentSong){\n            commit(SET_IS_LOADING, true);\n            dispatch(clearTimes);\n            commit(keyboardState + \"/\" + CLEAR_PRESSED_KEYS, {}, {root:true});\n            dispatch(menuState + \"/\" + stopPlaying, {}, {root:true});\n            \n            setTimeout(() => {\n                rootState.toneState.tone.Transport.stop();\n                rootState.toneState.tone.Transport.cancel();\n                dispatch(changeSong, currentSong);\n                commit(SET_IS_LOADING, false);\n            }, 10)\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}