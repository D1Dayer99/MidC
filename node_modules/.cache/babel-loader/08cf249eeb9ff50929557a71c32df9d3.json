{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { playlistState, toneState } from \"@/store/consts/states.js\";\nimport { SET_RECORDER, SET_IS_RECORDING, SET_START_RECORD_TIME, SET_END_RECORD_TIME, SET_SAVE_RECORDING, ADD_RECORD_MIDI, ADD_RECORD_AUDIO, ADD_RECORD_MAP, CLEAR_RECORD_MIDI, CLEAR_RECORD_AUDIO, CALCULATE_DURATION_AND_TIME_MIDI, ADD_NEW_RECORDED_SONG } from \"@/store/consts/mutation_types.js\";\nimport { createRecorder, recordMidiNote, startRecording, stopRecording, saveSong, connectSampler } from \"@/store/consts/actions.js\";\nexport default {\n  namespaced: true,\n  state: {\n    recorder: {},\n    recordedAudioChunks: [],\n    recordingHelperMap: {},\n    recordedMidiChunks: [],\n    startRecordTime: 0,\n    endRecordTime: 0,\n    isRecording: false,\n    saveRecording: false\n  },\n  mutations: {\n    [SET_RECORDER](state, val) {\n      state.recorder = val;\n    },\n    [SET_IS_RECORDING](state, val) {\n      state.isRecording = val;\n    },\n    [SET_START_RECORD_TIME](state, val) {\n      state.startRecordTime = val;\n    },\n    [SET_END_RECORD_TIME](state, val) {\n      state.endRecordTime = val;\n    },\n    [SET_SAVE_RECORDING](state, val) {\n      state.saveRecordingDialog = val;\n    },\n    [ADD_RECORD_MIDI](state, note) {\n      if (state.recordingHelperMap[note] != undefined) {\n        state.recordedMidiChunks.push({\n          name: state.recordingHelperMap[note].name,\n          startTime: state.recordingHelperMap[note].startTime,\n          endTime: new Date().getTime()\n        });\n        delete state.recordingHelperMap[note];\n      }\n    },\n    [ADD_RECORD_AUDIO](state, val) {\n      state.recordedAudioChunks.push(val);\n    },\n    [ADD_RECORD_MAP](state, note) {\n      state.recordingHelperMap[note] = {\n        name: note,\n        startTime: new Date().getTime(),\n        endTime: null\n      };\n    },\n    [CLEAR_RECORD_MIDI](state) {\n      state.recordedMidiChunks.length = 0;\n    },\n    [CLEAR_RECORD_AUDIO](state) {\n      state.recordedAudioChunks.length = 0;\n    },\n    [CALCULATE_DURATION_AND_TIME_MIDI](state) {\n      if (state.recordedMidiChunks.length != 0) {\n        state.recordedMidiChunks[0].time = state.recordedMidiChunks[0].startTime - state.startRecordTime;\n        state.recordedMidiChunks[0].duration = state.recordedMidiChunks[0].endTime - state.recordedMidiChunks[0].startTime;\n        for (let i = 1; i < state.recordedMidiChunks.length; i++) {\n          state.recordedMidiChunks[i].time = state.recordedMidiChunks[i - 1].time + state.recordedMidiChunks[i].startTime - state.recordedMidiChunks[i - 1].startTime;\n          state.recordedMidiChunks[i].duration = state.recordedMidiChunks[i].endTime - state.recordedMidiChunks[i].startTime;\n        }\n        for (let i = 0; i < state.recordedMidiChunks.length; i++) {\n          state.recordedMidiChunks[i].time /= 1000;\n          state.recordedMidiChunks[i].duration /= 1000;\n        }\n      }\n    }\n  },\n  actions: {\n    [createRecorder]({\n      rootState,\n      commit,\n      dispatch\n    }) {\n      const dest = rootState.toneState.tone.context.createMediaStreamDestination();\n      commit(SET_RECORDER, new MediaRecorder(dest.stream));\n      dispatch(toneState + \"/\" + connectSampler, dest, {\n        root: true\n      });\n    },\n    [recordMidiNote]({\n      commit\n    }, note) {\n      commit(ADD_RECORD_MAP, note);\n    },\n    [startRecording]({\n      commit,\n      state\n    }) {\n      commit(CLEAR_RECORD_MIDI);\n      commit(CLEAR_RECORD_AUDIO);\n      state.recorder.start();\n      state.recorder.ondataavailable = e => state.recordedAudioChunks.push(e.data);\n      commit(SET_IS_RECORDING, true);\n      commit(SET_START_RECORD_TIME, new Date().getTime());\n    },\n    [stopRecording]({\n      commit,\n      state\n    }) {\n      state.recorder.stop();\n      state.recorder.onstop = e => {\n        let blob = new Blob(state.recordedAudioChunks, {\n          type: 'audio/ogg; codecs=opus'\n        });\n        document.querySelector('audio').src = URL.createObjectURL(blob);\n      };\n      commit(SET_IS_RECORDING, false);\n      commit(SET_END_RECORD_TIME, new Date().getTime());\n      commit(CALCULATE_DURATION_AND_TIME_MIDI);\n      commit(SET_SAVE_RECORDING_DIALOG, true);\n      commit(playlistState + \"/\" + \"SET_CURRENT_SONG\", \"\", {\n        root: true\n      });\n    },\n    [saveSong]({\n      state,\n      commit\n    }, songName) {\n      const newSong = {\n        name: songName,\n        notes: Array.from(state.recordedMidiChunks),\n        forPlaylist: false\n      };\n      commit(playlistState + \"/\" + ADD_NEW_RECORDED_SONG, newSong, {\n        root: true\n      });\n      commit(SET_SAVE_RECORDING_DIALOG, false);\n    }\n  }\n};","map":{"version":3,"names":["playlistState","toneState","SET_RECORDER","SET_IS_RECORDING","SET_START_RECORD_TIME","SET_END_RECORD_TIME","SET_SAVE_RECORDING","ADD_RECORD_MIDI","ADD_RECORD_AUDIO","ADD_RECORD_MAP","CLEAR_RECORD_MIDI","CLEAR_RECORD_AUDIO","CALCULATE_DURATION_AND_TIME_MIDI","ADD_NEW_RECORDED_SONG","createRecorder","recordMidiNote","startRecording","stopRecording","saveSong","connectSampler","namespaced","state","recorder","recordedAudioChunks","recordingHelperMap","recordedMidiChunks","startRecordTime","endRecordTime","isRecording","saveRecording","mutations","val","saveRecordingDialog","note","undefined","push","name","startTime","endTime","Date","getTime","length","time","duration","i","actions","rootState","commit","dispatch","dest","tone","context","createMediaStreamDestination","MediaRecorder","stream","root","start","ondataavailable","e","data","stop","onstop","blob","Blob","type","document","querySelector","src","URL","createObjectURL","SET_SAVE_RECORDING_DIALOG","songName","newSong","notes","Array","from","forPlaylist"],"sources":["/Users/Sunhaoxiang/Desktop/IB_CS/CS_IA/src/store/modules/recordingState.js"],"sourcesContent":["import { playlistState, toneState } from \"@/store/consts/states.js\";\nimport { SET_RECORDER, \n    SET_IS_RECORDING,\n    SET_START_RECORD_TIME,\n    SET_END_RECORD_TIME,\n    SET_SAVE_RECORDING,\n    ADD_RECORD_MIDI,\n    ADD_RECORD_AUDIO,\n    ADD_RECORD_MAP,\n    CLEAR_RECORD_MIDI,\n    CLEAR_RECORD_AUDIO,\n    CALCULATE_DURATION_AND_TIME_MIDI,\n    ADD_NEW_RECORDED_SONG\n} from \"@/store/consts/mutation_types.js\";\nimport { createRecorder, \n    recordMidiNote,\n    startRecording,\n    stopRecording,\n    saveSong,\n    connectSampler\n  } from \"@/store/consts/actions.js\";\n\nexport default {\n    namespaced: true,\n\n    state: {\n       recorder: {},\n       recordedAudioChunks: [],\n       recordingHelperMap: {},\n       recordedMidiChunks: [],\n       startRecordTime: 0,\n       endRecordTime: 0,\n       isRecording: false,\n       saveRecording: false,\n    },\n\n    mutations: {\n        [SET_RECORDER](state, val){\n            state.recorder = val;\n        },\n        [SET_IS_RECORDING](state, val){\n            state.isRecording = val;\n        },\n        [SET_START_RECORD_TIME](state, val){\n            state.startRecordTime = val;\n        },\n        [SET_END_RECORD_TIME](state, val){\n            state.endRecordTime = val;\n        },\n        [SET_SAVE_RECORDING](state, val){\n            state.saveRecordingDialog = val;\n        },\n        [ADD_RECORD_MIDI](state, note){\n            if(state.recordingHelperMap[note] != undefined) {\n                state.recordedMidiChunks.push({\n                    name : state.recordingHelperMap[note].name,\n                    startTime : state.recordingHelperMap[note].startTime,\n                    endTime : new Date().getTime()\n                });\n\n                delete state.recordingHelperMap[note];\n            }\n        },\n        [ADD_RECORD_AUDIO](state, val){\n            state.recordedAudioChunks.push(val);\n        },\n        [ADD_RECORD_MAP](state, note){\n            state.recordingHelperMap[note] = {\n                name: note,\n                startTime : new Date().getTime(),\n                endTime : null\n            };\n        },\n        [CLEAR_RECORD_MIDI](state){\n            state.recordedMidiChunks.length = 0;\n        },\n        [CLEAR_RECORD_AUDIO](state){\n            state.recordedAudioChunks.length = 0;\n        },\n        [CALCULATE_DURATION_AND_TIME_MIDI](state){\n            if(state.recordedMidiChunks.length != 0){\n            \n                state.recordedMidiChunks[0].time = state.recordedMidiChunks[0].startTime - state.startRecordTime;\n                state.recordedMidiChunks[0].duration = state.recordedMidiChunks[0].endTime - state.recordedMidiChunks[0].startTime;\n    \n                for(let i = 1; i < state.recordedMidiChunks.length; i++){\n                    state.recordedMidiChunks[i].time = state.recordedMidiChunks[i - 1].time + state.recordedMidiChunks[i].startTime - state.recordedMidiChunks[i - 1].startTime\n                    state.recordedMidiChunks[i].duration = state.recordedMidiChunks[i].endTime - state.recordedMidiChunks[i].startTime;\n                }\n\n                for(let i = 0; i < state.recordedMidiChunks.length; i++){\n                    state.recordedMidiChunks[i].time /= 1000;\n                    state.recordedMidiChunks[i].duration /= 1000;\n                }\n            }\n        },\n    },\n\n    actions: {\n        [createRecorder]({ rootState, commit, dispatch }){\n            const dest  = rootState.toneState.tone.context.createMediaStreamDestination();\n            commit(SET_RECORDER, new MediaRecorder(dest.stream));\n            dispatch(toneState + \"/\" + connectSampler, dest, {root:true});\n        },\n\n        [recordMidiNote]({ commit }, note) {\n            commit(ADD_RECORD_MAP, note);\n        },\n\n        [startRecording]({ commit, state }){\n            commit(CLEAR_RECORD_MIDI);\n            commit(CLEAR_RECORD_AUDIO);\n\n            state.recorder.start();\n            state.recorder.ondataavailable = e => state.recordedAudioChunks.push(e.data);\n\n            commit(SET_IS_RECORDING, true);\n            commit(SET_START_RECORD_TIME, new Date().getTime());\n        },\n\n        [stopRecording]({ commit, state }){\n            state.recorder.stop();\n            state.recorder.onstop = e => {\n                let blob = new Blob(state.recordedAudioChunks, { type: 'audio/ogg; codecs=opus' });\n                document.querySelector('audio').src = URL.createObjectURL(blob);\n            };\n\n            commit(SET_IS_RECORDING, false);\n            commit(SET_END_RECORD_TIME, new Date().getTime());\n            commit(CALCULATE_DURATION_AND_TIME_MIDI);\n            commit(SET_SAVE_RECORDING_DIALOG, true);\n            commit(playlistState + \"/\" + \"SET_CURRENT_SONG\", \"\", {root:true});\n        },\n\n        [saveSong]({state, commit}, songName){\n            const newSong = {\n                name : songName,\n                notes : Array.from(state.recordedMidiChunks),\n                forPlaylist: false\n            };\n      \n            commit(playlistState + \"/\" + ADD_NEW_RECORDED_SONG, newSong, {root:true});\n            commit(SET_SAVE_RECORDING_DIALOG, false);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}